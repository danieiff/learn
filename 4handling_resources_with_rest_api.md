リクエストパラメータの種類
f：配下のエントリ一覧を取得
l：`?l={件数} 取得可能なエントリの最大件数(*ですべて　デフォルど100件）
c：配下のエントリ件数を取得
p：カーソル文字列 [*4-1](カーソル文字列とフェッチリミッター機能)

検索対象のデータが大量にある場合、ページネーションのように、１回のGETで取得するより複数のページにわけて検索する方がユーザ体験がよくなることがあります。ページネーションでは、取得可能なエントリの最大件数を絞って複数回検索することになります。続きのデータが存在する場合、レスポンスヘッダのx-vtecx-nextpageに次のページのカーソル文字列が自動的に設定されますので、?pにそのカーソル文字列を指定することで次ページを検索することができます。
　カーソル文字列が設定されるケースは、lパラメータで指定した件数を超えた場合とフェッチリミッター機能の上限に達した場合の２通りあります。
フェッチリミッター機能とは、サーバ負荷軽減のため検索条件検索（含む件数取得）や検索条件付きページネションにおいて一定の件数(50,000件)を検索（fetch）後に一旦終了するようにしている制御機能です。
検索件数上限に達すると、戻り値に検索したところまでのカーソル文字列を設定し、ステータス206(Partial Content)を返却します。
クライアントにおいて「p=カーソル文字列」の形でクエリ文字列に付加してリクエストすると、続きのページを取得できます。
なお、?l=*で検索した場合はフェッチリミッター機能は無視され、すべての検索が完了するまで実行されます。これを使用すると、データ件数が多い場合にサーバに大きな負荷がかかるため、通常は件数を指定するようにしてください。

###　Pagination
?lパラメータで指定した件数だけ取得した後、さらに次に続くデータを検索したい場合にページ数を指定して検索できると便利です。これをページネーション機能といいます。
ページネーション機能では、 GET {Key}?{検索条件}&n={ページ数}をリクエストすることで、指定されたページ数のデータを取得できます。また、l={件数}パラメータを指定することで、1ページあたりの件数を指定できます。
ただし、ページネーション機能を使うにはあらかじめカーソル一覧(pageindex)を作成しておく必要があります。以下のリクエストを実行することでカーソル一覧がセッションに保持されます。検索時、指定したページ数のカーソル一覧がセッションに存在しない場合は400エラーとなり、「Please make a pagination index in advance. 」のメッセージが返ります。また、検索した結果、最終ページ数に満たない場合は実際に張った最終ページ数が返ります。

GET {Key}?{検索条件}&_pagination={最終ページ数}&l={件数}
GET {Key}?{検索条件}&_pagination={開始ページ数},{最終ページ数}&l={件数}
大量のカーソル一覧(pageindex)を張るのは時間がかかるため、最初のリクエストは最終ページ数を50ぐらいにとどめておくのがおすすめです。(フェッチの最大実行回数である5万件を超える件数を検索した場合には206(Partial Content)が返ります）
　まず50ページ分をカーソル一覧に登録し、一旦画面に表示させたうえで、さらに続きを表示させる必要があれば、次の50〜100ページを張るようにします。ただし、開始ページ数を指定する場合、セッションに「開始ページ数-1ページ」のカーソルが登録されていなければエラーになりますので、開始ページ数には必ず前回実行した最終ページを指定するようにしてください。

### 検索
以下のように、URLパラメータに条件を指定することで絞り込み検索ができます。条件は「項目名=値」の形、もしくは、「項目名-記号-値」の形で指定します。項目名には、テンプレートの階層を"."でつないだ名称を指定します。
値はJavaScriptのencodeURIComponent()関数などで必ずエンコードしてください。値にもし&が含まれていると区切り文字と認識され、値が分割されて誤動作してしまいますのでご注意ください。具体的な条件検索の例についてはvtecxblankのチュートリアル(tutorial_2.html)に載せていますのでこちらもご覧ください。

文法

https://{サービス名}.vte.cx/{Key}?f&{name}{=|-eq-|-lt-|-le-|-gt-|-ge-|-ne-|-rg-|-fm-|-bm-|-ft-}{value}&{name}{=|-eq-|-lt-|-le-|-gt-|-ge-|-ne-|-rg-|-fm-|-bm-|-ft-}{value}&...&l={n}&p={カーソル文字列}&{ソート項目名}-desc|asc
例:好きな食べ物がeggで価格が5000以下を昇順で最大件数20件取得

https://{サービス名}.vte.cx/{Key}?f&subInfo.favorite.food-eq-egg&price-lt-5000&l=20&price-asc
記号の種類と意味は以下の通りです。

eq : = (等しい)
lt : < (未満)
le : <= (以下)
gt : > (より大きい)
ge : >= (以上)
ne : != (等しくない)
rg : regex (正規表現に合致する)
fm : 前方一致
bm : 後方一致
ft : 全文検索
asc : 昇順ソート
desc : 降順ソート
前方一致では、指定した文字の先頭文字が一致する条件となり、後方一致では、末尾文字が一致する条件になります。SQLで例えると、-fm-町は、LIKE '町%'に相当し、-bm-田は、LIKE '%田'に相当します。
あいまい検索を実行するには正規表現を使います。例えば、 -rg-.*田町.*は、`LIKE '%田町%'に相当します。

また、Keyに*を付けることで前方一致検索が可能です。例えば、"GET /men/to*"を実行すると、"/men/tokyo"、"/men/tops" などのエントリを検索できます。

OR検索

&|(と&)でOR条件を囲むことでOR検索ができます。括弧を省略する&|も使用できます。以下はOR条件の例です。

&|(title-rg-.*aaa.*&flg=1&)&|(subtitle-rg-.*bbb.*&flg=1&)
&|title-fm-aaa&|title-fm-bbb
注意点としては、カッコの入れ子は無し。また、カッコの中でOR条件を指定するのは無しという点です。以下は例です。

NG: &|title-fm-aaa&|(title-fm-bbb&|&(flg-eq-3&|flg-eq-4&)&)
OK: &|title-fm-aaa&|(title-fm-bbb&flg-eq-3&)&|(title-fm-bbb&flg-eq-4&)
また、&条件は全ての条件に適用されます。以下の例1、2は同じ条件です。

1: &|title-fm-aaa&|title-fm-bbb&flg=1
2: &|(title-fm-aaa&flg=1&)&|(title-fm-bbb&flg=1&)
全文検索で複数項目を対象にする

全文検索では複数項目を対象にすることができます。例えば、「nameまたはaddressが田中」かつ「nameまたはaddressが港区」という条件指定は以下のようにします。 ただし、複数項目を対象にする場合は、全文検索index指定(/_settings/templateのrightsタグ)において、|を使って複数の項目名を指定する必要があります。詳しくは、「全文検索Indexの設定」を参照してください。

name|address-ft-田中&name|address-ft-港区
項目が同じ場合、カンマを使って検索ワードのAND条件を1つにまとめる表現も指定可能です。以下は上記と同じ条件になります。

name|address-ft-田中,港区
上記条件で期待できる検索結果は、具体的には以下のパターンになります。

1. nameに 田中、addressに 港区
2. nameに 港区、addressに 田中
3. nameに 田中港区
4. addressに 田中港区
Indexの設定

条件検索はメモリ内で実行しますが、データ量が多いとパフォーマンス悪化を招きます。そのような場合、Indexを設定することで、パフォーマンスを向上させることができます。
ただし、Index検索を適用できるのは検索条件の最初の項目(一番左の項目)のみとなります。２番目以降の項目についてはIndex検索で絞り込み後にメモリ内で検索を実行します。例えば、?foo=123&bar=456という条件で検索した場合、fooにIndex設定があればIndex検索して絞り込みを行い、それからbarの検索をインメモリで実行します。
　また、Index検索の条件はgt、ge、lt、le、完全一致、前方一致である必要があり、暗号化項目は指定できません。(暗号化項目については以下を参照)２つ目以降の検索条件についてはあいまい検索や暗号化項目の検索が可能です。
　Indexは検索パフォーマンスを向上させる一方、書込パフォーマンスを悪化させるため、Index設定は必要最低限にすべきです。

　Indexの設定はテンプレートで行います。テンプレートとは、(/_settings/template)エントリのことで、Index設定はtemplateエントリのrightsタグに記述します。（管理画面のエントリスキーマ管理でも設定できます）
　以下のように、左辺の項目名に続けて:(コロン)の後に正規表現を記述することでIndexを設定できます。また、右辺に登録するURIのうち正規表現にマッチするものをIndexとして登録します。URIにはエントリの実体(self)や別名(alias)などを指定します。
　以下は、subInfo.favorite.food項目を/masterまたは/dataから検索した際にIndex検索となる設定例です。

subInfo.favorite.food:/master|/data　
全文検索Indexの設定

通常の検索以外に全文検索を行うことができます。全文検索を行うには、下記の全文検索Indexを設定したうえで、検索条件の記号を{項目名}-ft-{値}のように指定してください。
全文検索では、検索文字を形態素解析し、形態素解析結果の文字列数分、全文検索indexのクエリ検索を行います。形態素解析エンジンにはLuceneとlucene-analyzers-kuromoji-ipadic-neologdを使用しています。

　全文検索Indexの設定はテンプレート(/_settings/template)のrightsタグに記述します。
　以下のように、左辺の項目名に続けて;(セミコロン)の後に正規表現を記述することで全文検索Indexを設定できます。また、右辺に登録するURIのうち正規表現にマッチするものを全文検索Indexとして登録します。URIにはエントリの実体(self)や別名(alias)などを指定します。
　以下は、subInfo.favorite.food項目を/masterまたは/dataから検索した際に全文検索となる設定例です。

subInfo.favorite.food;/master|/data　
複数項目が対象の場合、左辺において、|を使って複数の項目を記述してください。

注意：検索条件と全文検索Indexの左辺は完全一致である必要があります。つまり、以下のリクエストは、subInfo.favorite.food|subInfo.favorite.music-ft-XXXのように指定してください。(項目の順序も一致させてください)

subInfo.favorite.food|subInfo.favorite.music;/master|/data　
ソートの指定

項目名-ascもしくは、?s={項目}パラメータを指定すると、その項目は昇順でソートされます。また、項目名-desc指定でその項目は降順となります。
ただし、ソート指定はページネーション検索とともに使う必要があります。これらは、基本的にメモリに展開するインメモリソートになるためパフォーマンスが悪くなる可能性があります。一方、ソート指定する項目にIndexの設定がなされているとレスポンスは高速になります。ソート指定でインデックスが有効な場合は以下のとおりです。

インデックス指定されたキーと項目であること
昇順
検索項目の先頭にソート指定
OR検索でないこと
また、index項目を検索する場合、その項目は昇順ソートされているため、ソート指定は不要です。
ソート指定をした項目が存在しない場合は検索できませんので注意してください。

?s=@keyを指定するとキー(link hrefの項目)でソートします。ただし、インメモリに展開するため指定しない場合に比べパフォーマンスが悪くなる場合があります。(デフォルトではkeyの昇順でソートされますがインメモリには展開されません)

OR検索の場合、デフォルトではOR検索条件ごとにソートされたものを合わせて返却します。OR検索内のソート項目は、OR検索内の第一条件がインデックス指定であればインデックス項目の昇順となります。インデックス項目でない場合、keyの昇順となります。

降順ソートを行いたい場合、検索項目とは別に降順用の項目(desc型)を追加すると高速に降順ソートができます。例えば、prop1_desc(desc)をエントリスキーマに定義するとprop1の値で降順ソート用のindexが作成されます。つまり、prop1_desc(desc)をtemplateのcontentに追加して、rightsに、prop1_desc:/endpointを追加することで、検索時にs=prop1_descを指定すると降順ソートになります。
desc型は降順ソートのindexを目的としたもので、実際の値を取得することはできません。GETしてもエントリの中にその項目は現れません。
インメモリソートの項目名-desc指定で降順ソートを行う場合、降順用の項目(desc型)の追加は必要ありません。
例
[parent].[child]|[parent].[child];/users
user.description|user.name|user.email;/users

#### nometaオプションとデータのバックアップ

_nometaオプションを付けてGET実行すると、id、author、published、updatedがついていないエントリが返ります。これは、データのバックアップを目的にしたもので、取得したFeedをPUT /d/?_bulkserial実行によりデータをリストアすることができます。(?_bulkserialオプションについては、「トランザクション処理と大量更新」を参照してください)
l=*と組み合わせて、GET /d/{キー}?f&_nometa&l=*と指定することでキー配下の全件のエントリを取得できます。

サーバの現在時刻の取得

GET /{d|s}?_nowでサーバの現在時刻を取得できます。

POSTによるエントリの登録

POSTにより複数のエントリを登録できます。(1回のPUTで最大1000件まで)
エントリのlink rel=selfタグのhref属性にキーを指定してPOSTを実行すると指定したキーで登録されます。以下を実行すると/foo/barエントリが登録されます。ただし、親フォルダである/fooは存在していなければなりません。
登録に成功すると、HTTPステータス201が返ります。エラーの場合はFeed.titleタグにエラーメッセージが返ります。

POST /d

<entry>
  ・・・
  <link href="/foo/bar" rel="self"/>     <!-- link rel="href" にKeyを指定します -->
</entry>
link rel=selfタグを省略して実行した場合、キーには自動的にユニークな番号が採番されて登録されます。ただし、URLに親階層フォルダ(/foo)を指定する必要があります。

POST /d/foo

<entry>
  ・・・       <!-- link rel=self は設定しません -->
</entry>
PUTによるエントリの更新

PUTにより複数のエントリを同時に登録更新できます。(最大1000件まで)
このとき、登録されるエンドポイントはエントリのキー(link rel=selfタグのhref属性)の値になります。更新されると、HTTPステータスが200(登録時は201)で、メッセージfeed.title:"Updated."を返します。
　楽観的排他チェックを行う場合はidを指定してください。(GETで取得したidをそのまま指定してください。+1する必要はありません。)
楽観的排他チェックでは、指定したidのエントリがデータベースに存在するかどうかのチェックを行います。更新が成功すると自動的にidがインクリメントされます。
　idを省略して更新すると楽観的排他チェックは行われず強制上書きとなります。また、PUTは登録も可能であり、既存のデータが存在しない場合は更新ではなく新規登録となります。登録では基本的にPOSTを使いますが一度に1000件以上の登録ができないため、実はPOSTを使う意味はほとんどありません。
また、PUTは部分更新であり以下のような注意点があります。

第一階層の項目に値が代入されているものを丸ごと置き換えます。
第二階層以下の項目が省略されている場合は更新されないことに注意してください。上書きで消したい場合はその項目に空白を代入する必要があります。
linkタグに関しては以下のように処理します。
rel属性の単位で設定されているものを置き換えます。
### トランザクション処理と大量更新
POSTやPUTによりFeed更新する際に1トランザクションで実行できるエントリは1000件までです。1000件を超える大量のエントリを更新するには、PUT /d/?_bulk等を使って実行する必要があります。ただし、このとき内部では1000件ずつ分割して実行していますので一貫性は担保されません。

PUTによる大量更新では、以下のように、並列/直列、同期/非同期の４種類の実行方法があります。直列実行では、先頭のエントリから1000件づつ実行し完了をまってから次の1000件を実行します。

PUT /d/?_bulk リクエストデータにFeed (並列同期処理)
PUT /d/?_bulk&_async リクエストデータにFeed (並列非同期処理)
PUT /d/?_bulkserial リクエストデータにFeed (直列同期処理)
PUT /d/?_bulkserial&_async リクエストデータにFeed (直列非同期処理)
DELETEによるリソースの削除

DELETE によりリソースを削除できます。
例えば、 DELETE /d/fooを実行すると、fooのリソース(コンテンツとメタデータ）を削除します。このとき、/foo配下にエントリが存在すると「Can't delete for the child entries exist.」エラーとなります。その場合、DELETE /d/foo?_rfを実行すると配下のエントリを含めて削除することができます。
DELETE /d/foo?r=1のように、rパラメータでリビジョンを指定すると楽観的排他チェックを行います。

トランザクション内でDELETEを実行する方法

PUTにより複数のエントリを１トランザクションで登録更新できますが、以下の方法で登録更新だけでなく削除も１トランザクション内で実行できます。

PUTするエントリのうち以下のものが削除される

エントリのidの後に?_deleteを指定（楽観的排他チェックが実行される）
例) /folder1/item,3?_delete
idに?_deleteのみ指定する（楽観的排他チェックは実行されない）
例) ?_delete
レスポンスの形式

リソースに対してGETを実行するとコンテンツが返ります。ただし、高速化のためETagによるレスポンスコントロールを行っています。つまり、前回参照したコンテンツに更新がなければ、304 Not Modifiedステータスを返します。

?eや?fでメタデータを検索した場合はfeedが返ります。
POSTやPUTなどの場合は基本的なレスポンスの形式は以下のような形になります。

<feed>
  <title>{メッセージ}</title>
</feed>
エラーの場合、HTTPステータスのみが返る場合があります。
詳しくは、「HTTPステータスコードとメッセージ」を参照してください。

### 採番と採番カウンタ

リソースやメタ情報とは別に採番や採番カウンタを持つことができます。これは、在庫数などの管理や連番が必要なケースで使うことを想定しています。

以下のようなメソッドが用意されています。

allocids（採番）
GET|PUT /d/?_allocids={採番数}を実行することで採番処理を行います。
指定された採番数だけ番号を採番します。カウンタ値はエンドポイント(キー)ごとに管理します。
採番数にマイナスの値を指定することはできません。1以上の値の指定が必要です。
DatastoreのallocateIdsを使用するため値はランダム値になります。
エラーの場合はFeed.titleにエラーメッセージが返ります。
setids（採番カウンタへの値のセット）
PUT /d/{キー}?_setids={設定値}パラメータを指定することで採番カウンタに設定値をセットします。
エラーの場合はFeed.titleにエラーメッセージが返ります。
addids（採番カウンタの加算）
PUT /d/{キー}?_addids={加算数}を実行することで採番カウンタの加算処理を行います。
パラメータで指定した加算数だけ採番の値をプラスしてその値を返します。
戻り値はFeed形式で、titleに加算後の現在値を設定します。
加算数にはマイナスの値を指定することが可能です。
GET /d/{キー}?_addidsを実行すると現在の採番カウンタの値を返します。
エラーの場合はFeed.titleにエラーメッセージが返ります。
rangeids（採番カウンタの範囲指定）
POST /d/{キー}?_rangeids で、bodyに{start}-{end}の形式を指定して実行すると採番範囲を設定できます。
採番範囲を1000から2000、つまり、初期値が1000で、2000を超えたら1000に戻るような設定にするには、bodyに1000-2000 を入れます。
GET /d/{キー}?_rangeidsで現在設定されている加算枠(addids用)を返却します。
戻り値はFeed.titleに「Addids range has been set.」が返ります。
エラーの場合はFeed.titleにエラーメッセージが返ります。
